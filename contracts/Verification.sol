pragma solidity ^0.4.24;

/**
 * Based upon ECDSA library from OpenZeppelin Solidity
 * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/cryptography/ECDSA.sol
 */

contract Verification {

  struct Certificate {
    uint id;
    bytes signature;

  }
  
  uint public certificateCount;
  
  address public authority;
  mapping(address => bool) public canSign;
  mapping(uint => Certificate) public certificates;

  constructor (address signer) public {
    authority = signer;
    //for (uint i=0; i < signers.length; i++) {
    canSign[signer] = true;
    //}
  }

  modifier isSigner(address user) {
    require(canSign[user] == true);
    _;
  }

  // storing message signature
  function setSign(bytes signed_msg) public returns(uint) {
    certificateCount++;
    certificates[certificateCount] = Certificate(certificateCount, signed_msg);
    return certificateCount;
  }

  /** 
   * @dev Recover signer address from a message by using their signature
   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.
   * @param signature bytes signature, the signature is generated using web3.eth.sign()
   */
  function recover(bytes32 hash, bytes signature)
    public
    pure
    returns (address)
  {
    bytes32 r;
    bytes32 s;
    uint8 v;

    // Check the signature length
    if (signature.length != 65) {
      return (address(0));
    }

    // Divide the signature in r, s and v variables
    // ecrecover takes the signature parameters, and the only way to get them
    // currently is to use assembly.
    // solium-disable-next-line security/no-inline-assembly
    assembly {
      r := mload(add(signature, 0x20))
      s := mload(add(signature, 0x40))
      v := byte(0, mload(add(signature, 0x60)))
    }

    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
    if (v < 27) {
      v += 27;
    }

    // If the version is correct return the signer address
    if (v != 27 && v != 28) {
      return (address(0));
    } else {
      // solium-disable-next-line arg-overflow
      return ecrecover(hash, v, r, s);
    }
  }
}
